import { AbstractDocument, MimeDocument, MultipartDocument } from '../entities/multipart-document.entity';
import { EncodingService } from '../services/encoding.service';

export class MultipartDocumentFactory {
  private contentType?: string;
  private boundary?: string;

  private parts: AbstractDocument[] = [];

  constructor(private encodingService: EncodingService) {
  }

  public setContentType(contentType: string): MultipartDocumentFactory {
    this.contentType = contentType;
    return this;
  }

  public setBoundary(boundary: string): MultipartDocumentFactory {
    this.boundary = boundary;
    return this;
  }

  public useAutoGeneratedBoundary(): MultipartDocumentFactory {
    const bytes = new Uint8Array(20);
    crypto.getRandomValues(bytes);
    const base32 = this.encodingService.wrap(this.encodingService.base32(bytes));

    this.boundary = base32;

    return this;
  }

  public addPart(part: AbstractDocument): MultipartDocumentFactory {
    this.parts.push(part);
    return this;
  }

  public build(): MultipartDocument {
    if (!this.contentType) {
      throw new Error('contentType must be set!');
    }

    if (!this.boundary) {
      throw new Error('boundary must be set!');
    }

    const result = new MultipartDocument(this.contentType, this.boundary);
    result.parts = [ ...this.parts ];
    return result;
  }
}

export class MimeDocumentFactory {
  private contentType?: string;
  private contentTransferEncoding?: string;
  private content?: string;
  private isAttachment?: boolean;
  private filename?: string;
  private name?: string;

  public constructor(private encodingService: EncodingService) {}

  public setContentType(contentType: string): MimeDocumentFactory {
    this.contentType = contentType;
    return this;
  }

  public setContentTransferEncoding(contentTransferEncoding: string): MimeDocumentFactory {
    this.contentTransferEncoding = contentTransferEncoding;
    return this;
  }

  public setContent(content: string): MimeDocumentFactory {
    this.content = content;
    return this;
  }

  public setPlainTextContent(content: string): MimeDocumentFactory {
    this.contentType = 'text/plain;charset=utf-8';
    this.contentTransferEncoding = 'quoted-printable';
    this.content = content;
    return this;
  }

  public setBinaryContent(content: Uint8Array): MimeDocumentFactory {
    this.contentTransferEncoding = 'base64';
    this.content = this.encodingService.wrap(
      this.encodingService.base64(content)
    );
    return this;
  }

  public attachment(): MimeDocumentFactory {
    this.isAttachment = true;
    return this;
  }

  public setFilename(filename: string) {
    this.filename = filename;
    return this;
  }

  public setName(name: string) {
    this.name = name;
    return this;
  }

  public build(): MimeDocument {
    if (!this.contentType) {
      throw new Error('contentType must be set!');
    }
    if (!this.contentTransferEncoding) {
      throw new Error('contentTransferEncoding must be set!');
    }
    if (!this.content) {
      throw new Error('content must be set!');
    }

    if (this.isAttachment && !this.filename) {
      throw new Error('filename must be set for attachments');
    }
    if (this.isAttachment && !this.name) {
      throw new Error('name must be set for attachments');
    }

    return new MimeDocument(
      this.contentType,
      this.contentTransferEncoding,
      this.content,
      this.isAttachment,
      this.filename,
      this.name
    );
  }
}
