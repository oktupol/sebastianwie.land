import { Injectable } from '@angular/core';
import { from, last, map, mergeMap, Observable, of, take, tap } from 'rxjs';
import { environment } from 'src/environments/environment';
import { MultipartDocument } from '../entities/multipart-document.entity';
import { MimeDocumentFactory, MultipartDocumentFactory } from '../factories/multipart-document.factory';
import { Message } from '../interfaces/message';
import { EncodingService } from './encoding.service';

@Injectable()
export class MultipartDocumentService {
  constructor(private encodingService: EncodingService) { }

  public multipartDocumentFactory(): MultipartDocumentFactory {
    return new MultipartDocumentFactory(this.encodingService);
  }

  public mimeDocumentFactory(): MimeDocumentFactory {
    return new MimeDocumentFactory(this.encodingService);
  }

  public createMultipartDocument(message: Message, messageId: string): Observable<MultipartDocument> {
    const factory = this.multipartDocumentFactory();

    factory.setContentType('multipart/mixed')
      .useAutoGeneratedBoundary()
      .setProtectedHeaders()
      .addHeader('Subject', message.subject)
      .addHeader('From', environment.contact.from)
      .addHeader('To', environment.contact.to)
      .addHeader('Message-ID', `<${messageId}>`)
      .addPart(this.mimeDocumentFactory()
        .setPlainTextContent(message.message)
        .build()
      );

    const attachments = message.attachments?.filter(attachment => attachment instanceof File);

    if (!attachments || attachments.length === 0) {
      return of(factory.build());
    } else {
      return from(attachments).pipe(
        mergeMap(attachment => this.readFileContents(attachment as File).pipe(
          map(buffer => ({ attachment: attachment as File, content: new Uint8Array(buffer) }))
        )),
        tap(({ attachment, content }) => {
          factory.addPart(this.mimeDocumentFactory()
            .attachment()
            .setName(attachment.name)
            .setFilename(attachment.name)
            .setContentType(attachment.type)
            .setBinaryContent(content)
            .build());
        }),
        last(),
        map(() => factory.build())
      );
    }
  }


  private readFileContents(file: File): Observable<ArrayBuffer> {
    return new Observable(subscriber => {
      if (!file) {
        subscriber.error('Parameter file must be given');
        subscriber.complete();
        return;
      }

      const reader = new FileReader();
      reader.onload = () => {
        if (reader.result instanceof ArrayBuffer) {
          subscriber.next(reader.result);
          subscriber.complete();
        } else {
          subscriber.error('While reading ' + file.name + ', expected ArrayBuffer as result. Got ' + typeof reader.result);
          subscriber.complete();
        }
      }
      reader.onerror = () => {
        subscriber.error('Error occurred during reading file ' + file.name);
        subscriber.complete();
      }

      reader.readAsArrayBuffer(file);
    });
  }
}
